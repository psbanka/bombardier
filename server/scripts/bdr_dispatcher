#!/usr/bin/env python
"Script to run dispatcher as a daemon"
import os, sys, time
import optparse
import termios, tty
import traceback
from bombardier_server.cnm.Dispatcher import Dispatcher
import resource, yaml
from bombardier_core.static_data import OK
from signal import SIGTERM

TIMEOUT=5
PIDFILE="/var/run/bdr_dispatcher.pid"
MAXFD = 1024
INFO_FILE = "dispatcher_info.yml"
os.environ["DJANGO_SETTINGS_MODULE"] = 'bombardier_server.web.rest_api.settings'
DEBUG_TRACE=False

def DEBUG(msg):
    fp = open("/tmp/DEBUG", "a")
    fp.write(msg)
    fp.write('\n')
    fp.flush()
    fp.close()

def trace_exit(value):
    if DEBUG_TRACE:
        traceback.print_stack()
    sys.exit(value)

def yaml_and_pidfile_or_die(server_home):
    yaml_file = os.path.join(server_home, INFO_FILE)
    start_time = time.time()
    while not (os.path.isfile(yaml_file) and os.path.isfile(PIDFILE)):
        time.sleep(1)
        if time.time() - start_time > TIMEOUT:
            trace_exit(TIMEOUT)

def get_process_info(server_home):
    yaml_file = os.path.join(server_home, INFO_FILE)
    while not os.path.isfile(yaml_file):
        time.sleep(1)
    try:
        info_dict = yaml.load(open(yaml_file, 'r').read())
        pid = open(PIDFILE).read().strip() #info_dict["dispatcher_pid"]
        uri = info_dict["dispatcher_uri"]
        return pid, uri
    except:
        trace_exit(1)

def refork(server_home, encryption_key):
    "Inner fork, sets up Dispatcher"
    yaml_file = os.path.join(server_home, INFO_FILE)
    os.setsid()
    try:
        pid = os.fork()
    except OSError, err:
        raise Exception, "%s [%d]" % (err.strerror, err.errno)

    if (pid != 0):
        yaml_and_pidfile_or_die(server_home)
        trace_exit(0)
    else:
        os.chdir(server_home)
        os.environ["PYRO_STORAGE"] = server_home
        import Pyro.core
        import Pyro.configuration
        #Pyro.configuration.PYRO_STORAGE = server_home
        data = Pyro.configuration.Pyro.config.PYRO_STORAGE
        Pyro.configuration.Pyro.config.PYRO_STORAGE = server_home
        Pyro.configuration.Pyro.config.PYRO_DETAILED_TRACEBACK = 1

        Pyro.core.initServer()
        daemon = Pyro.core.Daemon()
        dispatcher = Dispatcher(server_home, encryption_key)
        uri = str(daemon.connect(dispatcher, "dispatcher"))
        
        time.sleep(3)
        pid = str(os.getpid())
        info_dict = {"dispatcher_uri": str(uri)}
        try:
            open(yaml_file, 'w').write( yaml.dump(info_dict) )
            open(PIDFILE, 'w').write( "%s\n" % pid )
        except:
            dispatcher.terminate("not_root")
            trace_exit(1)
        test_pid, test_uri = get_process_info(server_home)
        actual_set = set([pid, uri])
        test_set = set([test_pid, test_uri]) 

        if not (actual_set == test_set):
            dispatcher.terminate("not_root")
            trace_exit(1)
        daemon.requestLoop()

def daemonize(server_home, encryption_key):
    "Create a deamon process from Dispatcher"
    os.chdir(server_home)
    yaml_file = os.path.join(server_home, INFO_FILE)
    os.environ["PYRO_STORAGE"] = server_home
    if os.path.isfile(yaml_file):
        os.unlink(yaml_file)
    try:
        pid = os.fork()
    except OSError, err:
        raise Exception, "%s [%d]" % (err.strerror, err.errno)

    if (pid == 0):
        refork(server_home, encryption_key)
    else:
        yaml_and_pidfile_or_die(server_home)
        return OK

    yaml_and_pidfile_or_die(server_home)
    maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if (maxfd == resource.RLIM_INFINITY):
        maxfd = MAXFD

    for file_descriptor in range(0, maxfd):
        try:
            os.close(file_descriptor)
        except OSError:
            pass

    os.dup2(0, 1)
    os.dup2(0, 2)

    return OK

def stop(server_home):
    "Stop the dispathcer"
    yaml_file = os.path.join(server_home, INFO_FILE)
    info_dict = yaml.load(open(yaml_file, 'r').read())
    pid = open(PIDFILE).read().strip()
    print "Stopping %s..." % pid
    return os.kill(int(pid), SIGTERM)

def usage(inputted):
    print "Action %s unknown. Please choose 'start' or 'stop'" % inputted
    parser.print_help()
    trace_exit(1)

def pwd_input(prompt):
    'ask for a password, providing asterisks for output'
    file_handle = sys.stdin.fileno()
    old_settings = termios.tcgetattr(file_handle)
    try:
        tty.setraw(sys.stdin.fileno())
        print prompt,
        password = ''
        while 1 == 1:
            char = sys.stdin.read(1)
            if char == chr(3): # ^C was pressed
                raise KeyboardInterrupt
            if char == chr(13): # Enter was pressed
                break
            if char == chr(8) or char == chr(127): # backspace
                if len(password) > 0:
                    sys.stdout.write("\b")
                    sys.stdout.write(" ")
                    sys.stdout.write("\b")
                    password = password[:-1]
                continue
            if ord(char) > 31 and ord(char) < 128: # Valid character
                sys.stdout.write("*")
                sys.stdout.flush()
                password += char
    except KeyboardInterrupt:
        termios.tcsetattr(file_handle, termios.TCSADRAIN, old_settings)
        trace_exit(1)
    termios.tcsetattr(file_handle, termios.TCSADRAIN, old_settings)
    redaction = "\b" * len(password) + " " * len(password)
    sys.stdout.write(redaction)
    print
    return password

if __name__ == "__main__":
    parser = optparse.OptionParser("usage: %prog <-h server-home> [start | stop]")
    parser.add_option("-d", "--decryption-key", dest="decryption_key",
                      help="Set the password for decrypting server configs")
    parser.add_option("-s", "--server-home", dest="server_home",
                      help="Set the server home directory (default /var/deploy)")

    (options, actions) = parser.parse_args()
    server_home = "/var/deploy"
    decryption_key = ''
    if options.server_home:
        server_home = options.server_home
    if options.decryption_key:
        decryption_key = options.decryption_key

    if len(actions) != 1:
        usage(actions)

    action = actions[0]


    if action == "start":
        key_file = os.path.join(server_home, "admin",
                                "encryption_validation.yml")
        if os.path.isfile(key_file):
            if decryption_key == '':
                try:
                    decryption_key = pwd_input("Enter decryption key:")
                except KeyboardInterrupt:
                    trace_exit(1)
        status = daemonize(server_home, decryption_key)
        pid, uri = get_process_info(server_home)
        #print ">>> ACTION:", action, uri
        trace_exit(status)
    elif action == "stop":
        trace_exit(stop(server_home))
    else:
        usage(action)

