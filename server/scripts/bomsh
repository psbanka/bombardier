#!/usr/bin/env python

import os, sys
sys.path.append('.')
from bombardier_server.cli.staticData import *

def tryImport(module):
    try:
        exec("import %s" % module)
    except ImportError:
        return FAIL
    return OK

def testModules():
    missingModules = []
    for module in ["yaml", "syck", "pexpect", "pxssh", "Crypto.Cipher"]:
        if tryImport(module) == FAIL:
            missingModules.append(module)
    if missingModules:
        print " %% ERROR: This system does not have the necessary Python libraries."
        print " %%%% You are missing these modules: %s" % ','.join(missingModules)
        print
        sys.exit(1)

def getInitialUserInput():
    print "This looks like a new installation of the Bombardier server."
    result = ''
    prompt = "Perform initial environment setup? (Y/n): "
    while result == '':
        instr = raw_input(prompt)
        if len(instr) == 0:
            break
        if instr.lower()[0] == 'y':
            break
        elif instr.lower()[0] == 'n':
            print "%% Aborting automatic system setup."
            print
            sys.exit(1)
    if sys.platform == "cygwin":
        serverHomeDefault = "/cygdrive/c/deploy"
        userDefault = "Administrator"
        platformDefault = "win32"
    else:
        serverHomeDefault = "/var/deploy"
        userDefault = "root"
        platformDefault = "linux"
    prompt = "Where do you want the root of your repository? [%s]: " % serverHomeDefault
    serverHome = raw_input(prompt)
    if serverHome == '':
        serverHome = serverHomeDefault
    prompt = "What is your default administrative account on clients? [%s]: " % userDefault
    user = raw_input(prompt)
    if user == '':
        user = userDefault
    prompt = "What is the default platform for clients? [%s]: " % platformDefault
    platform = raw_input(prompt)
    if platform == '':
        platform = platformDefault
    return serverHome, user, platform

def checkConfig():
    if not os.path.isfile(GLOBAL_CONFIG_FILE):
        serverHome, user, platform = getInitialUserInput()
        print "==> Making directories..."
        try:
            os.makedirs(os.path.join(serverHome))
        except OSError:
            print "%%%% Unable to create directory %s." % serverHome
            print "%% Aborting installation."
            sys.exit(1)
        print "==> Creating empty repository..."
        commands = []
        svnLocation = os.path.join(serverHome, "repos")
        tmpDir = os.path.join(serverHome, "tmp")
        os.makedirs(svnLocation)
        os.makedirs(tmpDir)
        commands.append("svnadmin create --fs-type fsfs %s > /dev/null" % svnLocation)
        commands.append("svn co file://%s %s > /dev/null" % ( svnLocation, tmpDir ))
        commands.append("svn mkdir %s > /dev/null" % os.path.join(tmpDir, "bom"))
        commands.append("svn mkdir %s > /dev/null" % os.path.join(tmpDir, "client"))
        commands.append("svn mkdir %s > /dev/null" % os.path.join(tmpDir, "include"))
        commands.append('svn ci %s -m "Creating initial directory structure" > /dev/null' % tmpDir)
        commands.append("rm -rf %s" % tmpDir)
        commands.append("svn co file://%s/bom %s/bom > /dev/null" % (svnLocation, serverHome))
        commands.append("svn co file://%s/client %s/client > /dev/null" % (svnLocation, serverHome))
        commands.append("svn co file://%s/include %s/include > /dev/null" % (svnLocation, serverHome))
        for command in commands:
            status = os.system(command)
            if status != OK:
                print "%% ERROR: could not perform repository creation commands"
                print "%% Failed at this command: %s" % command
                print "%% Aborting automated setup."
                sys.exit(1)
        try:
            os.makedirs(os.path.join(serverHome, "packages"))
            os.makedirs(os.path.join(serverHome, "output"))
            os.makedirs(os.path.join(serverHome, "status"))
        except OSError:
            "%%%% Error creating subdirectories."
            sys.exit(1)
        print "==> Making initial configuration file..."
        fh=open(GLOBAL_CONFIG_FILE, 'w')
        fh.write("---\n")
        fh.write("serverHome: %s\n" % serverHome)
        fh.write("defaultUser: %s\n" % user)
        fh.write("defaultPlatform: %s\n" % platform)
        fh.close()
        os.system("chmod 600 %s" % GLOBAL_CONFIG_FILE)
        print "==> Making initial DSL data file..."
        pkgsFile = os.path.join(serverHome, PACKAGES_FILE)
        fh = open(os.path.join(pkgsFile), 'w')
        fh.write("---\n")
        fh.write("{}")
        fh.close()
        os.system("chmod 600 %s" % pkgsFile)

testModules()
import syck
checkConfig()

import exceptions
import sys, os, readline, signal
import bombardier_server.cli.libUi
from bombardier_server.cli.commonUtil import *
from bombardier_server.cli.Slash import *
import optparse

mode.auth = USER

# READLINE CONFIGS
readline.parse_and_bind('tab: complete')
readline.parse_and_bind('C-z: "end\n"')
#readline.parse_and_bind('?: "\C-v?\t\d"')
readline.parse_and_bind('set bell-style none')
readline.set_completer_delims(' ')

if __name__ == "__main__":
    parser = optparse.OptionParser("usage: %prog -u user-name <bomsh-script>")
    parser.add_option("-u", "--user", dest="user", default=mode.username,
                      help="set the username associated with this session")
    (options, scripts) = parser.parse_args()
    if options.user:
        mode.username = options.user

    if scripts:
        status = OK
        filename = scripts[0]
        lines = open(filename, 'r').readlines()
        mode.batch = True
        for line in lines:
            cmdStatus, cmdOutput = slash.processCommand(line.strip())
            if status == OK:
                status = cmdStatus
        sys.exit(status)
    else:
        libUi.motd(slash.fpOut)
        if os.path.isfile(HISTORY_FILE):
            try:
                readline.read_history_file(HISTORY_FILE)
            except:
                print "%% Unable to read history file %s" % HISTORY_FILE
        clean = False
        logComment("User %s STARTED an interactive session" % mode.username)
        if mode.autoEnable:
            Enable.performEnable(slash)
        if mode.username == "root":
            try:
                mode.username = raw_input("Logging in as common user account. \nPlease provide your user name: ")
            except:
                sys.exit(0)
        while True:
            try:
                mode.setPrompt()
                readline.set_completer(slash.complete)
                if clean:
                    command = raw_input(mode.getPrompt())
                    clean = False
                else:
                    command = raw_input(mode.getPrompt()+readline.get_line_buffer())
                slash.processCommand(command)
            except EOFError, eof:
                if len(mode.exitMethods) > 0:
                    status, output = mode.exitMethods[-1](slash)
                    libUi.userOutput(output, status)
                else:
                    print
                    mode.clearBomConnections()
                    while mode.childProcesses:
                        os.kill(mode.childProcesses.pop(), signal.SIGTERM)
                    readline.write_history_file(HISTORY_FILE)
                    if mode.commentCommands:
                        makeComment()
                    logComment("User %s ENDED an interactive session" % mode.username)
                    sys.exit(0)
                mode.cleanMode(mode.state[-1])
                print
            except exceptions.KeyboardInterrupt, key:
                print
                clean = True

