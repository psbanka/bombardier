#!/opt/python2.5/bin/python

import traceback, StringIO
import exceptions
import sys, os, readline
import PinshCmd, Mode, libUi
from commonUtil import *

class Slash(PinshCmd.PinshCmd):
    def __init__(self, children):
        PinshCmd.PinshCmd.__init__(self, "")
        self.children = children
        self.cmdOwner = 1
        self.helpText = ''

    def processCommand(self, command):
        try:
            if mode.currentState() != Mode.FREE_TEXT:
                noFlag, helpFlag, tokens = libUi.processInput(command)
                if helpFlag: # Process the [?] key first
                    self.findHelp(tokens, 0)
                    #mode.reprompt()
                    return None
                if len(tokens) == 0:
                    return OK, []
                else:
                    status, output = self.run(tokens, noFlag, self)
            else:
                status, output = self.run(command, self)
            libUi.userOutput(output, status)
            return status, output
        except exceptions.SystemExit, e:
            sys.exit(0)
        except Exception, e:
            sys.stderr.write("Error detected in %s (%s)." % (file, e))
            e = StringIO.StringIO()
            traceback.print_exc(file=e)
            e.seek(0)
            data = e.read()
            ermsg = ''
            for line in data.split('\n'):
                ermsg += "\n||>>>%s" % line
            sys.stderr.write(ermsg)
            sys.stderr.write("\n")


##########################################################################
## Adding new commands:
## 
## 0. Create a class that extends PinshCmd
## 1. Import the class.
## 2. add the class to the following vector of command or add it to
##    the Configure.py class
    
import Bash, Ping, Telnet, Ssh, Terminal, Exit, BomCmd, Enable, Show
import For, Echo, UpdateClient, Set, Run, PushConfig

bomCommands = [ BomCmd.Status(), BomCmd.Uninstall(), 
                BomCmd.Verify(), BomCmd.Configure(), BomCmd.Install(), 
                BomCmd.Execute(), BomCmd.Purge(), BomCmd.Fix(), 
                BomCmd.Reconcile()]

commands = [Echo.Comment(), Set.Set(), Terminal.Terminal(), Show.Show(), Ping.Ping(), 
            Telnet.Telnet(), Ssh.Ssh(), Bash.Bash(), Run.Run(), PushConfig.PushConfig(),
            UpdateClient.UpdateClient(), Exit.Exit(), Enable.Enable(), For.For(), Echo.Echo()]

slash = Slash(commands + bomCommands)

##########################################################################

mode.auth = USER

# READLINE CONFIGS
readline.parse_and_bind('tab: complete')
readline.parse_and_bind('C-z: "end\n"')
#readline.parse_and_bind('?: "\C-v?\t\d"')
readline.parse_and_bind('set bell-style none')
readline.set_completer_delims(' ')
# Print the message of the day
if len(sys.argv) == 1:
    libUi.motd()

if __name__ == "__main__":

    if len(sys.argv) > 1:
        status = OK
        filename = sys.argv[-1]
        lines = open(filename, 'r').readlines()
        for line in lines:
            cmdStatus, cmdOutput = slash.processCommand(line.strip())
            if status == OK:
                status = cmdStatus
        sys.exit(status)
    else:
        if os.path.isfile(HISTORY_FILE):
            readline.read_history_file(HISTORY_FILE)
        while True:
            try:
                mode.setPrompt()
                readline.set_completer(slash.complete)
                command = raw_input(mode.getPrompt())
                slash.processCommand(command)
            except EOFError, eof:
                if mode.newClasses:
                    extraClasses = mode.newClasses[-1]
                    for i in range(0,extraClasses):
                        slash.children.pop()
                if mode.popPrompt() == FAIL:
                    print
                    mode.clearBomConnections()
                    readline.write_history_file(HISTORY_FILE)
                    sys.exit(0)
                mode.cleanMode(mode.state[-1])
                print
            except exceptions.KeyboardInterrupt, key:
                print
                pass
